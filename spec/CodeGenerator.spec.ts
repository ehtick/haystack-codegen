/*
 * Copyright (c) 2021, J2 Innovations. All Rights Reserved
 */

import { CodeGenerator, TypeGuardOptions } from '../src/CodeGenerator'
import { HDict, HList, HNamespace, HSymbol } from 'haystack-core'
import { DocCommentNode } from '../src/nodes/DocCommentNode'
import { resolveDefaultNamespace } from '../src/namespace'

describe('CodeGenerator', function (): void {
	let namespace: HNamespace

	describe('#generate()', function (): void {
		beforeAll(function (): void {
			jest.spyOn(
				DocCommentNode.prototype,
				'toDateString'
			).mockImplementation(() => 'date')
		})

		beforeEach(async function (): Promise<void> {
			namespace = await resolveDefaultNamespace()
		})

		it('generates a document for a site', function (): void {
			const code = new CodeGenerator({
				names: ['ahu'],
				namespace,
				typeGuardOptions: TypeGuardOptions.entity,
			}).generate()

			expect(code.trim()).toBe(
				`
/*
 * Automatically generated by haystack-codegen on date.
 */

import {
	HDict,
	HStr,
	HRef,
	HNamespace,
	valueIsKind,
	Kind,
} from 'haystack-core'

/**
 * Libraries used for code generation.
 */
export const LIBS = [
	{
		name: 'lib:phIoT',
		version: '3.9.10',
	},
	{
		name: 'lib:ph',
		version: '3.9.10',
	},
]

/**
 * marker
 *
 * Marker labels a dict with typing information.
 * See [Kinds chapter]\`docHaystack::Kinds#marker\`.
 */
export type Marker = HDict

/**
 * entity
 *
 * Top-level dicts with a unique identifier.
 * See \`docHaystack::Ontology#entities\` chapter.
 */
export interface Entity extends Marker {
	/**
	 * Display name for an entity.
	 * See \`docHaystack::Ontology#entities\` chapter.
	 */
	dis?: HStr

	/**
	 * Defines the unique identifier of an entity in system using a \`ref\` value
	 * type. The scope of an entity is undefined, but must be unique with a
	 * given system or project. This identifier may be used by other entities
	 * for cross-referencing.  See \`docHaystack::Ontology#entities\` chapter.
	 */
	id?: HRef
}

/**
 * equip
 *
 * Equipment asset.
 * See \`docHaystack::Equips\` chapter.
 */
export interface Equip extends Entity {
	/**
	 * Reference to equip which contains this entity
	 */
	equipRef?: HRef

	/**
	 * Reference to site which contains the entity
	 */
	siteRef?: HRef

	/**
	 * Reference to space which contains this entity
	 */
	spaceRef?: HRef
}

/**
 * Returns true if a value is a equip.
 *
 * An optional namespace can be passed in that will perform the check using defs.
 *
 * @param value The value to test.
 * @param namespace An optional namespace.
 * @returns true if the value matches.
 */
export function isEquip(value: unknown, namespace?: HNamespace): value is Equip {
	if (!valueIsKind<HDict>(value, Kind.Dict)) {
		return false
	}

	if (namespace) {
		return !!namespace.reflect(value)?.fits('equip')
	} else {
		return (
			value.has('equip') ||
			value.has('actuator') ||
			value.has('damper-actuator') ||
			value.has('valve-actuator') ||
			value.has('airHandlingEquip') ||
			value.has('ahu') ||
			value.has('doas') ||
			value.has('mau') ||
			value.has('rtu') ||
			value.has('fcu') ||
			value.has('crac') ||
			value.has('unitVent') ||
			value.has('heatPump') ||
			value.has('airTerminalUnit') ||
			value.has('cav') ||
			value.has('vav') ||
			value.has('ates') ||
			value.has('battery') ||
			value.has('boiler') ||
			value.has('hot-water-boiler') ||
			value.has('steam-boiler') ||
			value.has('chiller') ||
			value.has('circuit') ||
			value.has('conduit') ||
			value.has('duct') ||
			value.has('pipe') ||
			value.has('wire') ||
			value.has('coolingTower') ||
			value.has('flowInverter') ||
			value.has('fumeHood') ||
			value.has('heatExchanger') ||
			value.has('coil') ||
			value.has('coolingCoil') ||
			value.has('heatingCoil') ||
			value.has('humidifier-equip') ||
			value.has('luminaire') ||
			value.has('meter') ||
			value.has('elec-meter') ||
			value.has('ac-elec-meter') ||
			value.has('dc-elec-meter') ||
			value.has('flow-meter') ||
			value.has('motor') ||
			value.has('fan-motor') ||
			value.has('pump-motor') ||
			value.has('panel') ||
			value.has('controls-panel') ||
			value.has('elec-panel') ||
			value.has('plant') ||
			value.has('chilled-water-plant') ||
			value.has('hot-water-plant') ||
			value.has('steam-plant') ||
			value.has('rack') ||
			value.has('radiantEquip') ||
			value.has('chilledBeam') ||
			value.has('radiantFloor') ||
			value.has('radiator') ||
			value.has('tank') ||
			value.has('thermostat') ||
			value.has('ups') ||
			value.has('verticalTransport') ||
			value.has('elevator') ||
			value.has('escalator') ||
			value.has('movingWalkway') ||
			value.has('well')
		)
	}
}

/**
 * output
 *
 * Entity outputs a substance with flows to other entities
 */
export type Output = Marker

/**
 * air-output
 *
 * Entity outputs air to other entities
 */
export type Air_Output = Output

/**
 * input
 *
 * Entity inputs a substance which flows from another entity
 */
export type Input = Marker

/**
 * elec-input
 *
 * Entity inputs electricity which flows from another entity
 */
export interface Elec_Input extends Input {
	/**
	 * Electricity flows from the referent to this entity
	 */
	elecRef?: HRef
}

/**
 * airHandlingEquip
 *
 * HVAC equipment that conditions and delivers air via one or more fans.
 * Conditioning of air includes heating, cooling, humidification,
 * dehumidification, and ventilation. See \`docHaystack::AHUs\` chapter.
 */
export type AirHandlingEquip = Equip & Air_Output & Elec_Input

/**
 * Returns true if a value is a airHandlingEquip.
 *
 * An optional namespace can be passed in that will perform the check using defs.
 *
 * @param value The value to test.
 * @param namespace An optional namespace.
 * @returns true if the value matches.
 */
export function isAirHandlingEquip(value: unknown, namespace?: HNamespace): value is AirHandlingEquip {
	if (!valueIsKind<HDict>(value, Kind.Dict)) {
		return false
	}

	if (namespace) {
		return !!namespace.reflect(value)?.fits('airHandlingEquip')
	} else {
		return (
			value.has('airHandlingEquip') ||
			value.has('ahu') ||
			value.has('doas') ||
			value.has('mau') ||
			value.has('rtu') ||
			value.has('fcu') ||
			value.has('crac') ||
			value.has('unitVent') ||
			value.has('heatPump')
		)
	}
}

/**
 * ahu
 *
 * Air Handling Unit: An enclosure with a fan that delivers air to a space
 * via ductwork and performs one or more of the functions of cleaning,
 * heating, cooling, humidifying, dehumidifying, ventilating or circulating
 * the air.  See \`docHaystack::AHUs\` chapter.
 */
export type Ahu = AirHandlingEquip

/**
 * Returns true if a value is a ahu.
 *
 * An optional namespace can be passed in that will perform the check using defs.
 *
 * @param value The value to test.
 * @param namespace An optional namespace.
 * @returns true if the value matches.
 */
export function isAhu(value: unknown, namespace?: HNamespace): value is Ahu {
	if (!valueIsKind<HDict>(value, Kind.Dict)) {
		return false
	}

	if (namespace) {
		return !!namespace.reflect(value)?.fits('ahu')
	} else {
		return (
			value.has('ahu') ||
			value.has('doas') ||
			value.has('mau') ||
			value.has('rtu')
		)
	}
}
`.trim()
			)
		})

		it('does not create a namespace called `valueIsKind`', function (): void {
			namespace.grid.add(
				new HDict({
					def: HSymbol.make('valueIsKind:foo'),
				})
			)

			expect(
				new CodeGenerator({
					names: ['valueIsKind:foo'],
					namespace,
					typeGuardOptions: TypeGuardOptions.entity,
				}).generate()
			).toContain('export namespace valueIsKind_ {')
		})

		it('does not add values to an interface node that have the name of a property on HDict', function (): void {
			namespace.grid.add(
				new HDict({
					def: HSymbol.make('getKind'),
					is: new HList(HSymbol.make('marker')),
					tagOn: new HList([HSymbol.make('site')]),
				})
			)

			expect(
				new CodeGenerator({
					names: ['site'],
					namespace,
					typeGuardOptions: TypeGuardOptions.entity,
				}).generate()
			).not.toContain('getKind')
		})

		it('generates an isGeoPlace typeguard when all typeguards are generated', function (): void {
			expect(
				new CodeGenerator({
					names: ['discharge'],
					namespace,
					typeGuardOptions: TypeGuardOptions.all,
				}).generate()
			).toContain('isDischarge')
		})
	}) // #generate()
})
